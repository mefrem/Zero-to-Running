# Story 2.3: Startup Health Verification Automation

**Epic**: Epic 2 - Service Health & Observability

---

## Status

**Current Status**: Ready for Development

**Status Updated**: 2025-11-10 - Story created by Scrum Master (Bob). All acceptance criteria defined, comprehensive task breakdown provided, and technical architecture documented. Ready for development.

---

## Story

**As a** developer,
**I want** the `make dev` command to verify all services are healthy before completing,
**so that** I know the environment is truly ready when the command finishes.

---

## Acceptance Criteria

1. `make dev` polls each service's health endpoint until healthy or timeout (2 minutes)
2. Clear progress indicators show which services are starting vs. healthy vs. failed
3. If all services become healthy, command displays success message with access URLs and ports
4. If any service fails health checks, command displays specific error with troubleshooting suggestions
5. Command provides option to view service logs for failed health checks
6. Success message includes: Frontend URL, Backend API URL, Database connection string, Redis connection string

---

## Tasks / Subtasks

- [ ] Enhance startup script with health check polling mechanism (AC: 1)
  - [ ] Identify or create the orchestration entry point for `make dev` (likely in Makefile)
  - [ ] Create or enhance startup script at `/infrastructure/scripts/startup.sh` with health polling function
  - [ ] Implement polling loop for backend `/health/ready` endpoint with timeout (2 minutes total)
  - [ ] Implement polling logic with configurable timeout and retry interval
  - [ ] Handle HTTP errors gracefully (connection refused, 503 service unavailable, etc.)
  - [ ] Track elapsed time and display remaining timeout to user
  - [ ] Test with actual running services and with services that take time to become healthy

- [ ] Implement health check status indicators with clear progress display (AC: 2)
  - [ ] Design clear, readable progress indicator format (e.g., "Database: Starting → Healthy ✓")
  - [ ] Create output function that shows service status with color coding
  - [ ] Display database status: Starting → Healthy (uses Story 2.2 check-db-health.sh)
  - [ ] Display backend API status: Starting → Healthy → Failing (polls `/health/ready`)
  - [ ] Display frontend status: Starting → Healthy (checks port availability or health endpoint)
  - [ ] Display Redis status: Starting → Healthy (polls `/health/ready` cache field or direct ping)
  - [ ] Clear visual distinction between Starting, In Progress, Healthy, and Failed states
  - [ ] Add animated spinner or progress bar for long-running checks
  - [ ] Update display in real-time as services become healthy (refresh every 1-2 seconds)

- [ ] Create success message with access information (AC: 3, 6)
  - [ ] Display banner/header indicating successful startup
  - [ ] Display Frontend URL: `http://localhost:3000` (configurable via environment)
  - [ ] Display Backend API URL: `http://localhost:3001` (configurable via environment)
  - [ ] Display Database connection string: `postgresql://user:password@localhost:5432/zero_to_running_dev`
  - [ ] Display Redis connection string: `redis://localhost:6379`
  - [ ] Format information clearly with appropriate labels
  - [ ] Include instructions: "Press Ctrl+C to stop services" or similar
  - [ ] Optional: Display quick reference for common commands (make status, make logs, etc.)

- [ ] Implement error handling with troubleshooting guidance (AC: 4)
  - [ ] Detect timeout condition (2 minutes exceeded) and display clear error message
  - [ ] Identify which service(s) failed and why (connection refused, health check failed, etc.)
  - [ ] Provide specific troubleshooting suggestions based on failure type:
    - [ ] Database connectivity issues → suggest checking database logs, credentials, port
    - [ ] Backend API issues → suggest checking backend logs, health endpoint response
    - [ ] Frontend issues → suggest checking frontend logs, port conflicts
    - [ ] Redis issues → suggest checking Redis logs, connectivity
  - [ ] Include link to documentation (e.g., "See docs/troubleshooting.md for more help")
  - [ ] Display helpful error message with clear action items (e.g., "Try: make down && make dev")
  - [ ] Exit with non-zero status code on health check failure (to fail CI/CD pipelines)

- [ ] Add service logs viewing capability (AC: 5)
  - [ ] Provide option to view logs for failed service (e.g., "View logs? (y/n)")
  - [ ] If user confirms, run `make logs service=<failed_service_name>` automatically
  - [ ] Display last N lines of logs (default 50 lines, configurable)
  - [ ] Add flag to startup script: `--show-logs` to automatically show logs on failure
  - [ ] Document how to view logs manually using `docker-compose logs <service>`
  - [ ] Ensure logs can be viewed even if service is unhealthy or crashed

- [ ] Integrate health checks into Makefile make dev target (AC: 1-6)
  - [ ] Identify or create Makefile `dev` target that orchestrates startup
  - [ ] Update `make dev` to:
    - [ ] Run `docker-compose up -d` to start all services
    - [ ] Call startup script that performs health checking
    - [ ] Display progress during startup
    - [ ] Display success or failure message
    - [ ] Exit with appropriate status code
  - [ ] Ensure Makefile target runs sequentially (docker-compose up, then health checks)
  - [ ] Add help text explaining what `make dev` does

- [ ] Handle edge cases and resilience scenarios (AC: 1, 4)
  - [ ] Handle case where service container exits during health check
  - [ ] Handle case where Docker daemon is not running
  - [ ] Handle case where Docker containers already exist (idempotent health check)
  - [ ] Handle case where custom ports are configured (use environment variables)
  - [ ] Handle case where multiple instances of make dev run concurrently
  - [ ] Gracefully handle ctrl+c interruption during health checks
  - [ ] Cleanup resources if health checks timeout (stop services gracefully)

- [ ] Create comprehensive documentation for health verification (AC: 1-6)
  - [ ] Update README.md with information about `make dev` behavior and success output
  - [ ] Document timeout behavior (2 minutes, how to customize)
  - [ ] Create `/docs/HEALTH_VERIFICATION.md` explaining:
    - [ ] Overview of startup health verification system
    - [ ] What "healthy" means for each service
    - [ ] How to manually verify service health
    - [ ] Troubleshooting common startup issues
    - [ ] How to view service logs
    - [ ] Performance expectations (typical startup time)
    - [ ] Customization options (ports, timeouts, log levels)
  - [ ] Add examples of successful and failed startup output
  - [ ] Document environment variables that affect health checking (timeouts, retries, log levels)

- [ ] Add unit and integration tests for health verification script (AC: 1-6)
  - [ ] Create test file: `/infrastructure/scripts/__tests__/health-check-startup.test.sh`
  - [ ] Test health check polling loop with mocked services
  - [ ] Test timeout behavior (verify timeout at 2 minutes)
  - [ ] Test progress display format and output
  - [ ] Test success message generation and accuracy
  - [ ] Test error handling with various failure scenarios
  - [ ] Test log viewing capability integration
  - [ ] Test edge cases: container crash, port already in use, slow startup
  - [ ] Test with different environment configurations (custom ports, timeouts)
  - [ ] Ensure tests are deterministic and CI/CD compatible

- [ ] Validate all acceptance criteria are met (AC: 1-6)
  - [ ] Manual test: Run `make dev` with all services and verify health checks pass
  - [ ] Manual test: Run `make dev` and observe progress indicators update in real-time
  - [ ] Manual test: Observe success message with all four service URLs/connection strings
  - [ ] Manual test: Stop a service during startup and verify error message is helpful
  - [ ] Manual test: Test log viewing on failure
  - [ ] Manual test: Verify command exits with correct status code (0 for success, non-zero for failure)
  - [ ] Manual test: Verify timeout after 2 minutes (may use short timeout for testing)
  - [ ] Automated test: Run test suite and verify all tests pass
  - [ ] Verify documentation is complete and accurate
  - [ ] Run acceptance criteria checklist

---

## Dev Notes

### Project Context

This is Story 2.3 in Epic 2: Service Health & Observability. Stories 2.1 (Backend Health Check Implementation) and 2.2 (Database Health Verification) are complete and provide health endpoints/checks for individual services. This story focuses on orchestrating these health checks at the application startup level, ensuring developers get clear feedback that their environment is fully ready for development.

### Current Implementation Status

**Existing Components** (from Epic 1 & Stories 2.1-2.2):
- Docker Compose configuration at `/docker-compose.yml` with four services: postgres, redis, backend, frontend
- Backend health endpoints: `/health` and `/health/ready` (Story 2.1)
- Database health check script at `/infrastructure/scripts/check-db-health.sh` (Story 2.2)
- Database connection test function: `testDatabaseConnection()` in `/backend/src/config/database.ts`
- Redis connectivity: available through backend `/health/ready` endpoint
- Makefile with `dev`, `down`, and other targets
- Startup orchestration script (may exist in `/infrastructure/scripts/startup.sh`)

**What Needs to be Built for This Story:**
- Enhanced startup script with comprehensive health check polling mechanism
- Progress indicator system showing real-time service status
- Success message with all access information and connection strings
- Error handling with troubleshooting guidance
- Integration into `make dev` target to run automatically
- Service logs viewing capability on failure
- Tests and documentation for the health verification system

### Technical Architecture

**Health Check Flow**:
```
make dev
  ↓
Makefile: Run docker-compose up -d
  ↓
Makefile: Run startup script (/infrastructure/scripts/startup.sh)
  ↓
Startup Script: Check database (using /infrastructure/scripts/check-db-health.sh)
  ↓
Startup Script: Poll backend /health/ready endpoint (with 2-minute timeout)
  ↓
Startup Script: Poll frontend health (port check or health endpoint)
  ↓
Startup Script: Poll Redis health (via backend /health/ready cache field or direct ping)
  ↓
Startup Script: Display progress indicators in real-time
  ↓
Success: Display all service URLs and connection strings
  OR
Failure: Display error message and troubleshooting suggestions
```

**Service Health Endpoints/Checks**:
1. **Database** (PostgreSQL): `/infrastructure/scripts/check-db-health.sh` (AC 1 from Story 2.2)
   - Checks: connectivity, database exists, schema initialized
   - Timeout: 5 seconds per check
   - Called by startup script before backend starts

2. **Backend** (Express.js on port 3001): `GET /health/ready`
   - Returns: `{"status": "ready"/"unavailable", "database": "ok"/"error", "cache": "ok"/"error"}`
   - Timeout: 1 second per check (from Story 2.1)
   - HTTP 200 = healthy, 503 = unhealthy

3. **Frontend** (React on port 3000): Port availability check OR health endpoint
   - Check: TCP connection to `localhost:3000` succeeds
   - OR: `GET http://localhost:3000/` returns HTTP 200
   - Timeout: 1 second per check

4. **Redis** (port 6379): Backend `/health/ready` reports "cache": "ok"
   - Checked as part of backend health check
   - Alternative: Direct `PING` command via redis-cli

**Progress Indicator Format** (example):
```
Starting services...
Database:    Starting ⏳ → Checking → Healthy ✓
Backend API: Starting ⏳ → Checking → Healthy ✓
Cache:       Starting ⏳ → Checking → Healthy ✓
Frontend:    Starting ⏳ → Checking → Healthy ✓

SUCCESS! Environment ready for development.
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

Frontend:  http://localhost:3000
Backend:   http://localhost:3001
Database:  postgresql://postgres:@localhost:5432/zero_to_running_dev
Redis:     redis://localhost:6379

Run: make down    (stop services)
     make status  (show service status)
     make logs    (view service logs)
```

### File Locations & Naming Conventions

**Orchestration**:
- `/infrastructure/scripts/startup.sh` - Main startup script with health checking (may exist, needs enhancement)
- `/Makefile` - Root Makefile with `dev` target (enhancement needed)

**Health Checks** (already exist from previous stories):
- `/infrastructure/scripts/check-db-health.sh` - Database health verification (Story 2.2)
- `/backend/src/routes/health.ts` - Backend `/health` and `/health/ready` endpoints (Story 2.1)

**Documentation**:
- `/README.md` - Update with information about `make dev` and health verification
- `/docs/HEALTH_VERIFICATION.md` - Comprehensive health verification documentation (new)

**Tests**:
- `/infrastructure/scripts/__tests__/health-check-startup.test.sh` - Startup health check tests (new)

**Configuration**:
- Environment variables for health check tuning (timeouts, retries, log levels)
- `.env.example` - May need updates with health check variables

### Implementation Approach

**Startup Script Enhancement** (`/infrastructure/scripts/startup.sh`):

```bash
#!/bin/bash
# Main startup orchestration script

set -euo pipefail

# Configuration
HEALTH_CHECK_TIMEOUT=${HEALTH_CHECK_TIMEOUT:-120}  # 2 minutes
HEALTH_CHECK_INTERVAL=${HEALTH_CHECK_INTERVAL:-2}  # 2 seconds between checks
BACKEND_PORT=${BACKEND_PORT:-3001}
FRONTEND_PORT=${FRONTEND_PORT:-3000}
REDIS_PORT=${REDIS_PORT:-6379}
DATABASE_HOST=${DATABASE_HOST:-localhost}
DATABASE_PORT=${DATABASE_PORT:-5432}

# Color codes
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m'  # No color

# Function: Display progress for a service
display_progress() {
  local service=$1
  local status=$2
  printf "%-12s %s\n" "$service:" "$status"
}

# Function: Check backend health
check_backend_health() {
  curl -s -f "http://localhost:${BACKEND_PORT}/health/ready" > /dev/null 2>&1 && return 0 || return 1
}

# Function: Check frontend health
check_frontend_health() {
  curl -s -f "http://localhost:${FRONTEND_PORT}/" > /dev/null 2>&1 && return 0 || return 1
}

# Function: Poll services with timeout
poll_services_health() {
  local start_time=$(date +%s)
  local elapsed=0

  while [ $elapsed -lt $HEALTH_CHECK_TIMEOUT ]; do
    # Check each service
    display_progress "Database" "$(check_database_health && echo "✓ Healthy" || echo "⏳ Checking")"
    display_progress "Backend" "$(check_backend_health && echo "✓ Healthy" || echo "⏳ Checking")"
    display_progress "Frontend" "$(check_frontend_health && echo "✓ Healthy" || echo "⏳ Checking")"

    # If all healthy, return success
    # If all checks pass, exit loop

    elapsed=$(($(date +%s) - start_time))
    sleep $HEALTH_CHECK_INTERVAL
  done

  # Check if all services are healthy
  # Return 0 if yes, 1 if no
}

# Main execution
echo "Starting services..."
docker-compose up -d

echo "Verifying services are healthy..."
poll_services_health

if [ $? -eq 0 ]; then
  display_success_message
  exit 0
else
  display_error_message
  exit 1
fi
```

**Makefile Enhancement** (`make dev` target):
```makefile
dev: ## Start all services with health verification
  @echo "Starting development environment..."
  docker-compose up -d
  @./infrastructure/scripts/startup.sh
```

### Dependencies & Version Information

**External Commands Required**:
- `curl` - For checking HTTP health endpoints
- `docker` - For container orchestration
- `docker-compose` - For service orchestration
- `timeout` - For enforcing timeout limits (usually available in bash/sh)

**Bash Features Used**:
- Subshells with timeout
- Background process management
- String manipulation
- File I/O for logging

**Environment Variables** (all optional with defaults):
- `HEALTH_CHECK_TIMEOUT` - Total timeout for health checks (default: 120 seconds)
- `HEALTH_CHECK_INTERVAL` - Interval between checks (default: 2 seconds)
- `BACKEND_PORT` - Backend service port (default: 3001)
- `FRONTEND_PORT` - Frontend service port (default: 3000)
- `REDIS_PORT` - Redis service port (default: 6379)
- `DATABASE_PORT` - Database service port (default: 5432)
- `DATABASE_HOST` - Database host (default: localhost)
- `SHOW_LOGS_ON_FAILURE` - Display logs if health check fails (default: false)
- `LOG_LEVEL` - Logging verbosity (default: INFO)

### Known Constraints & Notes

1. **Backend Health Endpoint Dependency**: This story depends on backend `/health/ready` endpoint from Story 2.1. If backend crashes or fails to start, the health check will fail appropriately.

2. **Database Health Check Integration**: Uses `/infrastructure/scripts/check-db-health.sh` from Story 2.2 to verify database readiness before backend starts.

3. **Docker Network**: Services communicate via `zero-to-running-network` created in docker-compose.yml. Health checks from host machine use `localhost`.

4. **Service Startup Ordering**: Docker Compose handles dependency ordering via `depends_on` conditions. Health checks verify actual readiness beyond container startup.

5. **2-Minute Timeout**: AC1 specifies 2-minute total timeout. This allows for typical startup time (usually < 30 seconds) plus retry attempts.

6. **Idempotency**: Health checks should be idempotent - can be run multiple times safely without side effects.

7. **Port Conflicts**: Health check polling uses configured ports. If ports are already in use, health checks will fail appropriately with helpful error message (from Story 3.4).

8. **CI/CD Compatibility**: Must work in CI/CD environments without interactive prompts (except optional log viewing).

### Integration Points

- **Docker Compose**: Uses `docker-compose` commands to manage services
- **Makefile**: Called from `make dev` target
- **Backend Health Endpoints**: Polls `/health` and `/health/ready` from Story 2.1
- **Database Health Check**: Calls script from Story 2.2
- **Error Messages**: Should reference troubleshooting documentation from Story 4.3
- **Logs**: Integrates with `docker-compose logs` for viewing service logs
- **Status Command**: Works alongside `make status` command for ongoing monitoring

### Testing Requirements

**Test Scenarios**:
1. All services start successfully → display success message with all URLs
2. Backend takes time to become healthy → display progress, eventually show success
3. Backend never becomes healthy → timeout after 2 minutes, show error
4. Frontend down → show error for frontend, suggest troubleshooting
5. Database unhealthy → show error, suggest checking database logs
6. User interrupts (Ctrl+C) → cleanup gracefully
7. Services already running → idempotent health check
8. Custom ports configured → use environment variables for health checks
9. Logs requested on failure → display logs from failed service
10. Different log levels → verify output formatting

**Test Environment**:
- Local testing with running Docker Compose services
- CI/CD pipeline testing with timeouts configured for CI
- Mock/stub testing with curl mock responses

### Success Criteria

Story is complete when:
- `make dev` runs successfully with all services and displays success message
- Success message includes all four URLs/connection strings correctly
- Progress indicators update in real-time as services become healthy
- Timeout after 2 minutes of any service not becoming healthy
- Error messages are specific and actionable
- Logs can be viewed on failure via interactive prompt
- All acceptance criteria are validated
- Documentation is complete
- Tests pass

---

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-11-10 | 1.0 | Initial story creation for Epic 2.3 | Scrum Master (Bob) |

---

## Notes for Implementation

### Acceptance Criteria Mapping

- **AC 1**: `make dev` polls with 2-minute timeout - Task "Enhance startup script with health check polling mechanism" and "Integrate health checks into Makefile make dev target"
- **AC 2**: Clear progress indicators - Task "Implement health check status indicators with clear progress display"
- **AC 3**: Success message with URLs and ports - Task "Create success message with access information"
- **AC 4**: Error messages with troubleshooting - Task "Implement error handling with troubleshooting guidance"
- **AC 5**: Option to view logs - Task "Add service logs viewing capability"
- **AC 6**: Success message includes connection strings - Task "Create success message with access information"

### Implementation Order

1. **Start with Startup Script**: Enhance or create `/infrastructure/scripts/startup.sh` with health polling logic
   - Implement polling loop with timeout
   - Create health check functions for each service
   - Add progress display mechanism

2. **Implement Progress Indicators**: Create clear, real-time status display
   - Design simple progress format
   - Implement color-coded output
   - Update display as services become healthy

3. **Create Success Message**: Format and display all access information
   - Collect service URLs and ports from environment
   - Generate database and Redis connection strings
   - Display formatted success message

4. **Add Error Handling**: Detect failures and provide guidance
   - Identify which service failed
   - Determine failure reason (timeout, connection refused, etc.)
   - Provide specific troubleshooting suggestions

5. **Integrate with Makefile**: Update `make dev` target
   - Ensure docker-compose up runs first
   - Call startup script with error handling
   - Display results to user

6. **Add Logs Viewing**: Enable users to see failed service logs
   - Implement optional interactive prompt
   - Call `docker-compose logs` for requested service
   - Display last N lines of logs

7. **Create Documentation**: Write comprehensive guides
   - Update README with make dev behavior
   - Create HEALTH_VERIFICATION.md with details
   - Document troubleshooting steps

8. **Write Tests**: Create test suite for health verification
   - Unit tests for individual functions
   - Integration tests for full flow
   - Test edge cases and error scenarios

9. **Manual Validation**: Verify acceptance criteria
   - Run `make dev` and observe behavior
   - Test success and failure paths
   - Verify all criteria are met

### Key Considerations

- **Real-time Feedback**: Users should see progress updates during startup (important for long startup times)
- **Timeout Handling**: 2-minute timeout allows for normal startup plus retry attempts
- **Error Context**: Error messages should be specific about which service failed and why
- **Idempotency**: Health checks should be safe to run multiple times
- **Cross-platform**: Script should work on macOS, Linux, and WSL2 Windows
- **Container State**: Handle cases where containers exist but are stopped or unhealthy
- **Resource Cleanup**: Gracefully cleanup if health checks timeout

---
