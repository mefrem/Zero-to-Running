# Story 2.5: Developer Monitoring Dashboard

**Epic**: Epic 2 - Service Health & Observability

---

## Status

**Current Status**: Ready for Development

**Status Updated**: 2025-11-10 - Story created by Scrum Master. All requirements extracted from PRD, previous stories (2.1-2.4) context reviewed, and comprehensive technical guidance provided.

---

## Story

**As a** developer,
**I want** a simple monitoring view showing service status and key metrics,
**so that** I can quickly check the health of my environment at a glance.

---

## Acceptance Criteria

1. `make status` command displays table showing each service's status (running/stopped/unhealthy)
2. Status output includes uptime, resource usage (CPU, memory), and port mappings
3. Command indicates if any service is in unhealthy state with recommendation to check logs
4. Frontend dashboard page displays real-time health status of backend and dependencies
5. Dashboard auto-refreshes health status every 10 seconds
6. Dashboard shows backend API response time for the last health check

---

## Tasks / Subtasks

- [ ] Create status command script and Makefile target (AC: 1, 2, 3)
  - [ ] Create `/infrastructure/scripts/status.sh` script to query Docker Compose service information
  - [ ] Extract service status from `docker-compose ps` (running/stopped/unhealthy)
  - [ ] Extract uptime for each running service using `docker inspect`
  - [ ] Calculate and display CPU and memory usage using `docker stats` (with 1-second snapshot)
  - [ ] Extract port mappings from `docker-compose ps` and display in table format
  - [ ] Format output as readable ASCII table with service name, status, uptime, CPU, memory, ports
  - [ ] Detect unhealthy services and append recommendation: "Run 'make logs' to troubleshoot"
  - [ ] Handle case where services are not running (display clear message)
  - [ ] Add color coding for status: green (healthy), yellow (unhealthy/stopped), red (error)
  - [ ] Add help message for interpreting the output
  - [ ] Test script with running and stopped services

- [ ] Add `make status` target to Makefile (AC: 1, 2, 3)
  - [ ] Create `status` target that calls status.sh script
  - [ ] Add help text documenting `make status` command
  - [ ] Ensure script is executable and properly integrated

- [ ] Implement frontend health status dashboard page (AC: 4, 5, 6)
  - [ ] Create new dashboard component at `/frontend/src/components/Dashboard.tsx`
  - [ ] Design component to display service health status in grid or card layout
  - [ ] Implement real-time health check polling (10-second interval)
  - [ ] Display status for each service: Frontend, Backend, Database, Redis
  - [ ] Show status indicators: Healthy (green), Unhealthy (red), Checking (yellow)
  - [ ] Display last check timestamp for each service
  - [ ] Show backend API response time (milliseconds) from last health check
  - [ ] Implement auto-refresh mechanism using `setInterval` (10 second interval)
  - [ ] Add manual refresh button to force immediate health check
  - [ ] Handle loading state while fetching health data
  - [ ] Handle error states with user-friendly messages

- [ ] Create dashboard page routing and navigation (AC: 4, 5, 6)
  - [ ] Update `/frontend/src/App.tsx` to add route for dashboard page (e.g., `/dashboard` or `/status`)
  - [ ] Create navigation menu or links to access dashboard
  - [ ] Update landing page to include link to dashboard
  - [ ] Ensure dashboard is accessible from main application

- [ ] Implement backend health status endpoint for frontend (AC: 4, 5, 6)
  - [ ] Create new endpoint `/health/dashboard` that returns comprehensive health information
  - [ ] Return status and response time for all services from backend perspective
  - [ ] Include database connectivity status from backend
  - [ ] Include Redis connectivity status from backend
  - [ ] Return response in JSON format suitable for frontend dashboard display
  - [ ] Example response: `{ "status": "ready", "services": { "database": "ok", "cache": "ok" }, "timestamp": "...", "responseTime": 45 }`
  - [ ] Ensure endpoint is fast (< 1 second response time)

- [ ] Integrate frontend with backend health endpoint (AC: 4, 5, 6)
  - [ ] Update `/frontend/src/config/api.ts` with dashboard endpoint configuration
  - [ ] Create fetch utility function for dashboard health endpoint
  - [ ] Implement error handling for failed health checks
  - [ ] Display appropriate error messages if backend is unreachable
  - [ ] Test dashboard polling with various backend states

- [ ] Update landing page to show quick status (AC: 4)
  - [ ] Modify existing landing page to display health status in corner/badge
  - [ ] Show overall system health: Green (All healthy), Yellow (Some unhealthy), Red (Critical)
  - [ ] Link to full dashboard for detailed status
  - [ ] Ensure landing page remains simple and not cluttered

- [ ] Add dashboard styling and UX (AC: 4)
  - [ ] Use Tailwind CSS for professional appearance
  - [ ] Implement responsive design for different screen sizes
  - [ ] Use color coding consistent with CLI status command
  - [ ] Add icons or symbols for visual status indication (✓ for healthy, ✗ for unhealthy, ⟳ for checking)
  - [ ] Display information in clear, scannable format
  - [ ] Add tooltips explaining each metric

- [ ] Create or update dashboard documentation (AC: 1-6)
  - [ ] Document `make status` command in README.md
  - [ ] Explain output format and status indicators
  - [ ] Document how to access frontend dashboard page
  - [ ] Explain refresh interval and response times
  - [ ] Include troubleshooting: "If services show unhealthy, run `make logs` to investigate"
  - [ ] Add example output from `make status` command
  - [ ] Create `/docs/MONITORING.md` with comprehensive dashboard guide

- [ ] Implement testing for status command (AC: 1-3)
  - [ ] Create tests at `/infrastructure/scripts/__tests__/status.test.sh`
  - [ ] Test status output format (table structure)
  - [ ] Test status detection (running, stopped, unhealthy)
  - [ ] Test uptime calculation accuracy
  - [ ] Test port mapping extraction
  - [ ] Test color coding output (with/without color option)
  - [ ] Test with various service states (all running, some stopped, some unhealthy)
  - [ ] Test error handling (Docker not running, compose not available)

- [ ] Implement testing for dashboard frontend component (AC: 4-6)
  - [ ] Create tests at `/frontend/src/__tests__/Dashboard.test.tsx`
  - [ ] Test component renders with health data
  - [ ] Test auto-refresh mechanism (verify interval set to 10 seconds)
  - [ ] Test manual refresh button functionality
  - [ ] Test error state handling
  - [ ] Test loading state display
  - [ ] Test API response time display formatting
  - [ ] Test timestamp formatting and display

- [ ] Implement integration tests (AC: 1-6)
  - [ ] Test `make status` command with running Docker Compose stack
  - [ ] Verify status output matches actual service states
  - [ ] Test frontend dashboard makes requests to `/health/dashboard` endpoint
  - [ ] Verify dashboard auto-refreshes every 10 seconds
  - [ ] Test response time calculation and display
  - [ ] Test error handling when services are down
  - [ ] Create integration test script at `/infrastructure/scripts/__tests__/monitoring-integration.test.sh`

- [ ] Update docker-compose.yml health checks if needed (AC: 1, 4, 5, 6)
  - [ ] Review existing health checks to ensure they're accurate
  - [ ] Ensure `/health` endpoint is properly configured for all service health checks
  - [ ] Verify timeout values are appropriate (< 1 second)
  - [ ] Document health check strategy in docker-compose.yml comments

- [ ] Validate all acceptance criteria are met (AC: 1-6)
  - [ ] Manual test: Run `make status` and verify table format
  - [ ] Manual test: Verify all columns present (Service, Status, Uptime, CPU, Memory, Ports)
  - [ ] Manual test: Stop a service with `docker-compose pause [service]` and verify status updates
  - [ ] Manual test: Verify unhealthy service shows recommendation to check logs
  - [ ] Manual test: Access frontend dashboard at configured URL
  - [ ] Manual test: Verify dashboard displays health for all services (Frontend, Backend, DB, Redis)
  - [ ] Manual test: Watch dashboard auto-refresh every 10 seconds
  - [ ] Manual test: Verify response time appears and updates
  - [ ] Manual test: Click manual refresh button and verify immediate update
  - [ ] Manual test: Stop backend and verify dashboard shows unhealthy state
  - [ ] Automated tests: Run all test suites and verify 100% pass rate
  - [ ] Code quality: Run TypeScript and ESLint checks - zero errors
  - [ ] Run acceptance criteria checklist

---

## Dev Notes

### Project Context

This is Story 2.5 in Epic 2: Service Health & Observability - the final story for this epic. Stories 2.1-2.4 are complete and provide essential health check and logging infrastructure:

- **Story 2.1** (COMPLETE): Backend health check endpoints (`/health`, `/health/ready`) with database and Redis connectivity verification
- **Story 2.2** (COMPLETE): Database health verification script with connection and schema validation
- **Story 2.3** (COMPLETE): Startup health verification automation with 2-minute timeout and progress indicators
- **Story 2.4** (COMPLETE): Structured JSON logging with Pino (timestamp, level, message, service, requestId), configurable LOG_LEVEL, API request/response logging, database query logging in DEBUG mode, and `make logs` command with service filtering

Story 2.5 leverages these capabilities to provide developers with a comprehensive monitoring view of their environment status.

### Current Implementation Status

**Existing Components** (from Epic 1 & Stories 2.1-2.4):
- Complete Docker Compose setup with 4 services: Frontend (React/TypeScript/Tailwind), Backend (Node/Express/TypeScript), PostgreSQL, Redis
- Custom Docker network (zero-to-running-network) with DNS-based service discovery
- Health check endpoints: `/health` (basic status), `/health/ready` (with dependency checks)
- Database health verification script (check-db-health.sh)
- Startup health verification automation (startup.sh with health polling)
- Structured JSON logging using Pino with requestId and timestamp propagation
- `make logs` command with service filtering and follow mode
- Makefile with dev, down, and other targets

**What Needs to be Built for Story 2.5:**
- CLI `make status` command showing service status, uptime, resource usage, and port mappings
- Frontend dashboard page displaying real-time health status
- Backend `/health/dashboard` endpoint with comprehensive health information
- 10-second auto-refresh mechanism for dashboard
- Response time tracking and display
- Error handling and unhealthy service indicators
- Tests and comprehensive monitoring documentation

### Technical Architecture

**`make status` Command Architecture:**
```
make status
  ↓
status.sh script
  ↓
docker-compose ps → Parse service status (running/stopped/unhealthy)
  ↓
docker inspect → Extract uptime for each service
  ↓
docker stats → Get CPU and memory usage (1-second snapshot)
  ↓
docker-compose config → Extract port mappings
  ↓
Format as ASCII table with color coding:
┌──────────┬─────────┬────────┬─────┬────────┬──────────┐
│ Service  │ Status  │ Uptime │ CPU │ Memory │ Ports    │
├──────────┼─────────┼────────┼─────┼────────┼──────────┤
│ Frontend │ Healthy │ 5m 32s │ 0.5%│ 125MB  │ 3000     │
│ Backend  │ Healthy │ 5m 35s │ 1.2%│ 180MB  │ 3001     │
│ Postgres │ Healthy │ 5m 40s │ 0.8%│ 95MB   │ 5432     │
│ Redis    │ Healthy │ 5m 41s │ 0.3%│ 42MB   │ 6379     │
└──────────┴─────────┴────────┴─────┴────────┴──────────┘

If unhealthy service found:
  Append: "⚠ Unhealthy service detected. Run 'make logs' to troubleshoot."
```

**Frontend Dashboard Architecture:**
```
Dashboard Component (/frontend/src/components/Dashboard.tsx)
  ↓
Renders: Health Status Grid with 4 service cards (Frontend, Backend, Database, Redis)
  ↓
useEffect with setInterval (10-second polling)
  ↓
Fetches: GET /health/dashboard
  ↓
Backend Response:
{
  "status": "ready",
  "services": {
    "backend": "ok",
    "database": "ok",
    "cache": "ok"
  },
  "timestamp": "2025-11-10T14:30:45.123Z",
  "responseTime": 45
}
  ↓
Updates state with health data
  ↓
Renders status indicators:
- Healthy: Green circle + text "Healthy"
- Unhealthy: Red circle + text "Unhealthy"
- Checking: Yellow circle + spinner + text "Checking..."
  ↓
Displays response time: "Response Time: 45ms"
  ↓
Display last check timestamp
  ↓
Auto-refresh every 10 seconds via setInterval
```

**Backend `/health/dashboard` Endpoint:**
```
GET /health/dashboard
  ↓
Check /health endpoint status (basic health)
  ↓
Check database connectivity (from backend perspective)
  ↓
Check Redis connectivity (from backend perspective)
  ↓
Record response time (start to finish)
  ↓
Return JSON:
{
  "status": "ready",
  "services": {
    "backend": "ok",
    "database": "ok",
    "cache": "ok"
  },
  "timestamp": "2025-11-10T14:30:45.123Z",
  "responseTime": 45
}
```

### File Locations & Naming Conventions

**CLI Status Command**:
- `/infrastructure/scripts/status.sh` - CLI status query script
- `/infrastructure/scripts/__tests__/status.test.sh` - Status script tests
- `/Makefile` - Status target (e.g., `status: @bash infrastructure/scripts/status.sh`)

**Frontend Dashboard**:
- `/frontend/src/components/Dashboard.tsx` - Dashboard page component
- `/frontend/src/__tests__/Dashboard.test.tsx` - Dashboard tests
- `/frontend/src/App.tsx` - Updated with dashboard route

**Backend Endpoint**:
- `/backend/src/routes/health.ts` - Updated to include `/health/dashboard` endpoint

**Frontend API Configuration**:
- `/frontend/src/config/api.ts` - Updated with dashboard endpoint

**Documentation**:
- `/docs/MONITORING.md` - Comprehensive monitoring dashboard guide (new)
- `/README.md` - Updated with monitoring section
- `/infrastructure/scripts/__tests__/monitoring-integration.test.sh` - Integration tests

### Implementation Approach

**Phase 1: CLI Status Command**
1. Create status.sh script to query Docker Compose
2. Parse docker-compose ps for service status (running/stopped/unhealthy)
3. Extract uptime from docker inspect for each running service
4. Get CPU/memory from docker stats (1-second snapshot)
5. Extract port mappings from docker-compose config
6. Format as ASCII table with color coding
7. Detect and report unhealthy services with recommendation
8. Add Makefile target and help text

**Phase 2: Backend Dashboard Endpoint**
1. Create /health/dashboard endpoint
2. Query database connectivity (SELECT 1 test)
3. Query Redis connectivity (PING test)
4. Measure response time
5. Return comprehensive JSON response
6. Handle timeouts and errors gracefully

**Phase 3: Frontend Dashboard Component**
1. Create Dashboard.tsx component
2. Design service health grid/card layout
3. Implement real-time health polling (10-second interval)
4. Display status indicators with color coding
5. Show response time from backend
6. Display timestamps
7. Implement manual refresh button
8. Handle loading and error states
9. Create tests

**Phase 4: Integration & Documentation**
1. Update landing page with quick status indicator
2. Add dashboard route to App.tsx
3. Create MONITORING.md documentation
4. Update README.md with monitoring section
5. Create integration tests
6. Validate all acceptance criteria

### Dependencies & Version Information

**Backend Dependencies** (for /health/dashboard endpoint):
- Express.js (already available)
- pg (PostgreSQL client - already available)
- redis (Redis client - already available)

**Frontend Dependencies** (for Dashboard component):
- React 18+ (already available)
- TypeScript (already available)
- Tailwind CSS (already available)

**System Tools** (for status.sh script):
- docker - Get container stats, inspect, and status
- docker-compose - Get service status and configuration
- awk, sed, grep - Text processing for table formatting
- bc - For numeric calculations (CPU/memory percentages)

**Environment Variables** (all optional with sensible defaults):
- HEALTH_CHECK_INTERVAL - Polling interval for dashboard (default: 10 seconds)
- STATUS_SHOW_COLORS - Enable/disable color in status output (default: true)
- DASHBOARD_REFRESH - Dashboard auto-refresh interval in milliseconds (default: 10000)

### Known Constraints & Notes

1. **Docker Stats Performance**: `docker stats` requires a 1-second wait to get accurate data; status command will add ~1 second to execution time
2. **Response Time Measurement**: Backend response time includes network roundtrip + processing time
3. **Health Check Frequency**: Frontend polls every 10 seconds; real-time changes may have up to 10-second latency
4. **Resource Usage Snapshot**: CPU/memory values are snapshots; historical data would require additional infrastructure
5. **Port Mapping Display**: Shows mapped ports; internal container ports are always standard (3000, 3001, 5432, 6379)
6. **Unhealthy State Definition**: Service is unhealthy if health check fails or container is in error state
7. **Color Output**: Status script auto-detects terminal support; use `NO_COLOR=1` environment variable to disable colors

### Integration Points

- **Docker Compose**: Uses `docker` and `docker-compose` CLI commands for status and stats
- **Makefile**: Called via `make status` target
- **Backend Health**: Builds on `/health` and `/health/ready` endpoints from Story 2.1
- **Startup Script**: Can be called from `startup.sh` for post-startup status verification
- **Logs Command**: Can recommend `make logs` when services are unhealthy
- **Frontend**: Dashboard page integrated into React app routing
- **Monitoring**: Provides real-time visibility into environment health

### Testing Requirements

**Test Scenarios for Status Command (AC: 1-3)**:
1. Status displays table with all 4 services when all running
2. Status shows "healthy" for each running service
3. Status shows "stopped" for stopped services
4. Status shows "unhealthy" for services with failed health checks
5. Status displays uptime correctly (format: Xm Ys or Xh Ym Ys)
6. Status displays CPU and memory percentages
7. Status displays port mappings correctly
8. Status shows recommendation to check logs for unhealthy services
9. Status handles case where Docker is not running
10. Status handles case where no services are running

**Test Scenarios for Dashboard (AC: 4-6)**:
1. Dashboard component renders with health data
2. Dashboard displays status for all 4 services
3. Dashboard shows health status indicators (color-coded)
4. Dashboard shows response time from backend
5. Dashboard shows last check timestamp
6. Dashboard auto-refreshes every 10 seconds
7. Dashboard manual refresh button forces immediate update
8. Dashboard displays loading state while fetching
9. Dashboard displays error state when backend unreachable
10. Dashboard gracefully handles network errors

**Test Scenarios for /health/dashboard Endpoint (AC: 4-6)**:
1. Endpoint returns 200 status with valid JSON
2. Endpoint includes "status", "services", "timestamp", "responseTime"
3. Services object includes "backend", "database", "cache"
4. Service values are "ok" or "error"
5. Response time is in milliseconds
6. Endpoint responds in < 1 second normally
7. Endpoint handles database down gracefully
8. Endpoint handles Redis down gracefully
9. Endpoint includes error details when services are down

### Success Criteria

Story is complete when:
- `make status` command displays table format with all required information (AC: 1, 2, 3)
- Status command correctly identifies unhealthy services and shows recommendation (AC: 3)
- Frontend dashboard page accessible and displays real-time health status (AC: 4)
- Dashboard auto-refreshes every 10 seconds (AC: 5)
- Dashboard displays backend response time (AC: 6)
- All acceptance criteria validated and documented
- All tests passing (unit, integration, acceptance)
- TypeScript and ESLint: zero errors
- Comprehensive monitoring documentation created
- Story is approved and ready for development

---

## Dev Notes

### Testing

**Test File Locations:**
- CLI Status Tests: `/infrastructure/scripts/__tests__/status.test.sh`
- Frontend Dashboard Tests: `/frontend/src/__tests__/Dashboard.test.tsx`
- Integration Tests: `/infrastructure/scripts/__tests__/monitoring-integration.test.sh`

**Testing Frameworks:**
- Backend: Jest + Supertest (for API endpoint testing)
- Frontend: Jest + React Testing Library
- CLI Scripts: BATS (Bash Automated Testing System) or manual shell script tests

**Testing Standards** (from existing project):
- All unit tests should be in `__tests__` directories
- Frontend tests use React Testing Library for component testing
- Backend endpoint tests use Supertest for HTTP testing
- All tests documented with clear test case names
- Target: 80%+ code coverage for critical paths
- Test files run as part of CI/CD pipeline

---

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-11-10 | 1.0 | Initial story creation for Epic 2.5 | Scrum Master (Bob) |

---

## Next Steps After Development

**Story 2.5 Handoff Notes:**
- After development is complete, Epic 2: Service Health & Observability is COMPLETE
- All four epics (1, 2, 3, 4) will have started or be ready to begin
- Story 2.5 provides the final monitoring capability for developers to verify environment health
- Consider if additional monitoring enhancements are needed (e.g., historical metrics, log-based alerting, external monitoring integration)
- Coordinate dashboard styling with frontend design standards

**Quality Assurance**:
- QA should verify status command output format and accuracy
- Test dashboard functionality across different browsers (Chrome, Firefox, Safari)
- Validate response time calculations are accurate
- Test edge cases: all services down, partial failures, network timeouts
- Verify auto-refresh mechanism works reliably over extended periods
- Test with various Docker states and configurations

**Documentation**:
- Ensure MONITORING.md covers all dashboard features and CLI command options
- Include troubleshooting section for common issues (missing Docker stats, port conflicts, etc.)
- Document dashboard refresh behavior and latency expectations
- Provide examples of what healthy vs. unhealthy status looks like
