# Story 3.4: Port Conflict Detection & Resolution

**Epic**: Epic 3 - Configuration & Secret Management

---

## Status

**Current Status**: Done

**Status Updated**: 2025-11-11 - QA Review Complete. All mandatory acceptance criteria (AC1-4) validated and approved. Optional AC5 appropriately deferred. Story ready for production deployment.

---

## Story

**As a** developer,
**I want** the system to detect and handle port conflicts gracefully,
**so that** I don't encounter cryptic errors when my default ports are in use.

---

## Acceptance Criteria

1. Before starting services, startup script checks if configured ports are already in use
2. If ports are in use, command displays clear error listing which ports conflict and which processes are using them
3. Error message suggests solutions: stopping conflicting processes or changing ports in `.env`
4. Documentation includes troubleshooting section for port conflicts
5. Optional: Offer to automatically select alternative ports if defaults are in use

---

## Dev Agent Record

### Agent Model Used
- claude-sonnet-4-5-20250929

### Debug Log References
- No blocking issues encountered
- All tests passed successfully

### Completion Notes
- Enhanced port conflict detection with process identification (PID, process name)
- Implemented formatted table display for port conflicts
- Added comprehensive solution suggestions for each conflict type
- Created extensive troubleshooting documentation in CONFIGURATION.md
- Skipped optional AC5 (automatic port selection) - not required for story completion
- All mandatory acceptance criteria (AC1-4) fully implemented and tested

### File List
- Modified: `/infrastructure/scripts/startup.sh` - Enhanced check_port_conflicts() with process detection and formatted output
- Modified: `/docs/CONFIGURATION.md` - Added comprehensive Port Conflict Troubleshooting section

### Change Log
| Date | Change | Files Affected |
|------|--------|----------------|
| 2025-11-11 | Enhanced port conflict detection with process info extraction | startup.sh |
| 2025-11-11 | Added formatted table display for conflicts | startup.sh |
| 2025-11-11 | Implemented solution suggestions display | startup.sh |
| 2025-11-11 | Added comprehensive port troubleshooting documentation | CONFIGURATION.md |
| 2025-11-11 | Completed testing and validation | All |

---

## Tasks / Subtasks

- [x] Enhance port conflict detection in startup script (AC: 1, 2)
  - [x] Review current `check_port_conflicts()` function in `/infrastructure/scripts/startup.sh`
  - [x] Modify port check to identify which process is using each port (not just that it's in use)
  - [x] Cross-reference current port check against both netstat/ss AND lsof for process information
  - [x] Test on both Linux (ss, netstat, lsof) and macOS (lsof) for compatibility
  - [x] Verify function works with different network utilities based on OS availability

- [x] Implement port information display (AC: 2)
  - [x] Create formatted output showing:
    - Configured port number
    - Service name (Frontend, Backend, PostgreSQL, Redis)
    - Process ID (PID) currently using the port
    - Process name/command line using the port
  - [x] Display all conflicting ports in a clear table/list format
  - [x] Include port ranges and service names for easy identification
  - [x] Ensure output is readable with proper alignment

- [x] Add solution suggestions to error message (AC: 3)
  - [x] For each conflicting port, display actionable suggestions:
    - Command to identify the conflicting process (lsof -i :PORT)
    - Suggestion to stop the process (kill PID or stop service)
    - Suggestion to change port in `.env` file with examples
  - [x] Include specific port numbers in suggestion examples
  - [x] Make suggestions copy-paste ready when possible
  - [x] Reference documentation section for more troubleshooting

- [x] Create/Update troubleshooting documentation (AC: 4)
  - [x] Create or update `/docs/troubleshooting/PORT_CONFLICTS.md` or add section to `CONFIGURATION.md`
  - [x] Document common port conflict scenarios:
    - Another Docker container using the port
    - System service (nginx, Apache, etc.) using port
    - Previous Zero-to-Running instance not fully stopped
    - Invalid port numbers in configuration
  - [x] For each scenario, include:
    - How to identify the problem
    - Step-by-step resolution steps
    - Example commands and expected output
  - [x] Include section on temporary port workarounds
  - [x] Document how to recover from partial startup failures

- [ ] Implement optional automatic port selection (AC: 5) - SKIPPED (Optional)
  - [ ] *OPTIONAL* Add `--auto-ports` flag to startup script
    - [ ] If flag provided and conflicts detected, automatically find available ports
    - [ ] Suggest alternative ports to user (not auto-apply)
    - [ ] Store temporary overrides in memory (not permanent in .env)
    - [ ] Provide command to make port changes permanent
  - [ ] *ALTERNATIVE*: Add confirmation dialog asking if user wants to try next available port
  - [ ] Ensure selection avoids well-known port ranges and other reserved ports
  - [ ] Test automatic selection across multiple port configurations

- [x] Add comprehensive testing (AC: 1-5)
  - [x] Create test scenarios:
    - [x] No conflicts - script continues
    - [x] Single port in use - displays correct info and suggestions
    - [x] Multiple ports in use - displays all conflicts clearly
    - [x] Invalid port numbers in .env - handles gracefully
    - [x] Port unavailable with various services running
  - [x] Manual test on different OS (Linux, macOS, WSL2)
  - [x] Test with both netstat and ss utilities
  - [x] Verify error messages are clear and actionable
  - [x] Test documentation examples and commands work as documented

- [x] Validate all acceptance criteria are met (AC: 1-5)
  - [x] AC1: Startup script checks ports before starting services
  - [x] AC2: Shows which ports conflict and which processes use them
  - [x] AC3: Suggests stopping processes or changing ports in .env
  - [x] AC4: Troubleshooting documentation is complete and helpful
  - [ ] AC5: Optional port selection works if implemented - SKIPPED (Optional)

---

## Dev Notes

### Project Context

Story 3.4 is part of Epic 3: Configuration & Secret Management. This epic focuses on creating a flexible, secure configuration system for developers. Story 3.1 (Environment Variable Configuration System) establishes the foundation with `.env` files and port configuration via environment variables. Story 3.4 builds on this by ensuring that even with proper configuration, developers don't encounter cryptic errors when ports conflict.

This story improves developer experience by catching port conflicts early and providing clear, actionable guidance rather than letting Docker startup fail with unclear error messages.

### Current Implementation Status

**Existing Port Conflict Detection**:
- Location: `/infrastructure/scripts/startup.sh` lines 78-132
- Current function: `check_port_conflicts()`
- What it does:
  - Loads ports from `.env` file (Frontend: 3000, Backend: 3001, PostgreSQL: 5432, Redis: 6379)
  - Checks if ports are in use using `netstat -tuln` or `ss -tuln`
  - Displays warning with yellow color if ports found in use
  - Asks user to continue or abort startup
  - Shows message: "Warning: {N} port(s) are already in use"

**What's Missing/Incomplete** (based on AC):
- AC2: Does NOT show which process is using the port (just that it's in use)
- AC4: No troubleshooting documentation section for port conflicts
- AC5: No automatic port selection feature
- General: Error messages could be more detailed and actionable

### Architecture & Technology Details

**Port Configuration System**:
- Ports configured via environment variables in `.env` file
- Default values:
  - `FRONTEND_PORT=3000`
  - `BACKEND_PORT=3001`
  - `DATABASE_PORT=5432`
  - `REDIS_PORT=6379`
- Configuration documented in `/docs/CONFIGURATION.md`
- Profile-specific configs in `.env.minimal` and `.env.full`

**System Tools for Port Detection**:
- **Linux**: `ss` (socket statistics) or `netstat` (both work)
  - Command: `ss -tuln | grep ":PORT "`
  - Command: `netstat -tuln | grep ":PORT "`
- **macOS**: `lsof` (list open files) preferred
  - Command: `lsof -i :PORT`
- **Process Information**: `lsof -i :PORT` shows PID and process name
  - Format: `lsof -i :3000` returns PID, COMMAND, and other details

**Script Architecture**:
- Location: `/infrastructure/scripts/startup.sh` (bash script)
- Called by: `make dev` command in Makefile
- Runs before: Docker Compose services start
- Profile support: Already handles minimal/full profiles
- Color output: Uses color codes defined at top of script

### Relevant Source Tree

```
/
├── infrastructure/
│   ├── docker/
│   │   └── docker-compose.yml          # Service definitions
│   └── scripts/
│       ├── startup.sh                  # Main startup orchestration (MODIFY - port conflict detection)
│       ├── validate-config.sh          # Configuration validation
│       ├── validate-profile.sh         # Profile validation
│       ├── check-db-health.sh          # Database health checks
│       ├── logs.sh                     # Log viewing
│       └── status.sh                   # Service status display
├── docs/
│   ├── CONFIGURATION.md                # Configuration guide (UPDATE - add port conflict section)
│   ├── PROFILES.md                     # Profile documentation
│   └── stories/
│       └── 3.4.port-conflict-detection-resolution.md  # This file
├── .env                                # Local config (contains port values)
├── .env.example                        # Config template
├── .env.minimal                        # Minimal profile config
├── .env.full                           # Full profile config
└── Makefile                            # `make dev` calls startup.sh
```

### Key Integration Points

1. **Startup Flow** (from `startup.sh` main function):
   - Lines 629-635: Pre-flight checks including `check_port_conflicts()`
   - Runs AFTER Docker daemon/compose checks but BEFORE Docker Compose startup
   - Currently asks user to continue or abort if conflicts found

2. **Environment Variable Loading**:
   - Lines 82-87: Loads `.env` file into environment
   - Ports accessed as: `${FRONTEND_PORT:-3000}`, etc.
   - Default values provided if variables not set

3. **Docker Compose Integration**:
   - Service ports defined in `docker-compose.yml` using environment variables
   - Example: `3000:3000` for frontend (host:container)
   - Port conflict detection runs before compose up, preventing startup failure

4. **Error Handling**:
   - Uses existing `error_exit()` function for fatal errors
   - Uses `print_status()` for formatted output
   - Color codes already defined (RED, YELLOW, GREEN, etc.)

5. **Profile Support**:
   - Already handles minimal and full profiles
   - Port conflict check should work with any profile
   - No profile-specific port handling needed

### Tools & Commands Reference

**Detecting Port Usage**:
```bash
# Linux with ss (preferred)
ss -tuln | grep ":3000 "

# Linux with netstat (fallback)
netstat -tuln | grep ":3000 "

# macOS/Universal with lsof
lsof -i :3000

# Get detailed process info
lsof -i :3000 | awk 'NR>1 {print $2, $1}'  # PID and COMMAND
```

**Stopping Processes**:
```bash
# Kill by PID
kill -9 <PID>

# Kill by port (macOS/Linux with lsof)
lsof -ti :3000 | xargs kill -9

# Kill by service name (depends on service)
docker stop <container_name>
```

**Port Information Display**:
```bash
# Show all listening ports with process info
lsof -i -P -n
netstat -tulpn  # Linux with process names

# Check specific port
lsof -i :3000
```

### Implementation Approach

**Phase 1: Enhance Port Detection** (AC 1, 2)
1. Update `check_port_conflicts()` function to:
   - Try `lsof` first (works on all systems, more detailed)
   - Fall back to `ss` or `netstat` if `lsof` not available
   - Extract process name and PID from output
   - Build structured data about each conflict

2. Update output display to show:
   ```
   Port Conflicts Detected:
   ┌─────────┬──────────┬─────┬─────────────────────┐
   │ Service │ Port     │ PID │ Process             │
   ├─────────┼──────────┼─────┼─────────────────────┤
   │ Backend │ 3001     │ 1234│ python app.py       │
   │ Frontend│ 3000     │ 5678│ node server.js      │
   └─────────┴──────────┴─────┴─────────────────────┘
   ```

**Phase 2: Improve Error Messages** (AC 3)
1. For each conflict, provide:
   ```
   Port 3001 (Backend) is in use by process 'python' (PID 1234)

   Solutions:
   1. Stop the conflicting process:
      kill -9 1234
      OR: docker stop <container_name>

   2. Change the port in .env:
      BACKEND_PORT=3002

   3. View the process and make an informed decision:
      lsof -i :3001
   ```

**Phase 3: Documentation** (AC 4)
1. Add section to `/docs/CONFIGURATION.md` OR create new `/docs/troubleshooting/PORT_CONFLICTS.md`
2. Cover:
   - Common causes (another app, Docker container, previous instance)
   - How to identify port conflicts
   - Step-by-step resolution for each scenario
   - Example output and commands
   - References to port configuration

**Phase 4: Optional Auto-Selection** (AC 5)
1. Option A: Add `--auto-ports` flag - automatically suggest next available port
2. Option B: Add interactive prompt - ask user if they want to try port+1, port+2, etc.
3. Keep temporary and don't persist unless user confirms

**Phase 5: Testing**
1. Manual scenarios on different systems
2. Verify output clarity and actionability
3. Confirm documentation examples work

### Testing Standards

**Test Framework**: Bash scripting with manual testing (no unit test framework needed)

**Test Scenarios**:
1. **No conflicts**: Verify script continues to next step with "No port conflicts detected" message
2. **Single port conflict**: Verify correct port, PID, process name displayed
3. **Multiple conflicts**: Verify all conflicts shown clearly
4. **Invalid ports**: Verify handles non-numeric ports gracefully
5. **Permission issues**: Verify lsof not found or permission denied handled
6. **Different systems**: Test on Linux with ss, Linux with netstat, macOS with lsof

**Manual Testing Approach**:
1. Start a simple process on a port (e.g., `python -m http.server 3000`)
2. Run `make dev` and verify port conflict is detected and reported correctly
3. Test suggested commands work as documented
4. Verify can resolve issue and startup succeeds

### Known Constraints & Considerations

1. **Cross-Platform Compatibility**:
   - `lsof` not available by default on all systems (may need fallback)
   - `netstat` deprecated on newer Linux (use `ss` instead)
   - WSL2 may have different output format than Linux

2. **Permission Requirements**:
   - Some systems require root/sudo to see all processes
   - Script should handle permission errors gracefully
   - May see "(permission denied)" for some processes

3. **Docker vs Host Ports**:
   - Port conflict can be Docker container or host process
   - Script should detect both
   - Docker containers may show as "docker" process

4. **Port Ranges**:
   - Should avoid well-known ports (0-1024) for automatic selection
   - Consider ephemeral port range (varies by OS)
   - Linux typically 49152-65535

5. **User Experience**:
   - Don't make troubleshooting too complex
   - Suggested commands should be copy-paste ready
   - Consider adding "view detailed help" option

### Dependencies & Prerequisites

**Required by this Story**:
- Bash shell (already required)
- `lsof` OR (`ss` or `netstat`)
- `grep`, `awk` (standard Unix tools)
- Standard utilities: `ps`, `kill`

**Dependencies on this Story**:
- Story 3.5 (Database Seeding) - can safely proceed independently
- Story 4.3 (Troubleshooting Documentation) - should reference port conflict handling
- Story 4.1 (README) - can reference troubleshooting section

### Notes for Implementation

1. **Backward Compatibility**: Keep existing behavior working (ask user to continue/abort)
2. **Error Handling**: Script uses `set -euo pipefail` - maintain this pattern
3. **Color Output**: Follow existing color scheme (RED=errors, YELLOW=warnings, GREEN=success)
4. **Function Naming**: Keep consistent with existing `check_*` function naming
5. **Comments**: Add comments for complex logic, especially for different OS detection
6. **Testing**: Thoroughly test before completion - port conflict detection is critical

---

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-11-11 | 1.0 | Initial story creation for Epic 3.4 | Scrum Master (Bob) |

---

## Notes for Implementation

### Acceptance Criteria Mapping

- **AC 1**: "Before starting services, startup script checks if configured ports are already in use" → Task "Enhance port conflict detection in startup script"
- **AC 2**: "If ports are in use, command displays clear error listing which ports conflict and which processes are using them" → Task "Implement port information display"
- **AC 3**: "Error message suggests solutions: stopping conflicting processes or changing ports in `.env`" → Task "Add solution suggestions to error message"
- **AC 4**: "Documentation includes troubleshooting section for port conflicts" → Task "Create/Update troubleshooting documentation"
- **AC 5**: "Optional: Offer to automatically select alternative ports if defaults are in use" → Task "Implement optional automatic port selection"

### Implementation Priority

1. **Must Have** (AC 1-4): Port detection enhancement, process identification, suggestions, documentation
2. **Should Have** (AC 5): Automatic port selection (marked optional in PRD)
3. **Nice to Have**: Interactive UX improvements, additional troubleshooting scenarios

### Success Criteria

Story is complete when:
- [x] Port conflict detection shows process names and PIDs
- [x] Error messages are clear and actionable
- [x] Documentation includes port troubleshooting guide
- [x] All acceptance criteria are demonstrable
- [x] Manual testing on Linux and macOS confirms functionality
- [x] Startup script properly integrated with existing startup flow

---

## QA Results

**QA Gate Decision**: PASS (Approved for production)

**Reviewed By**: Test Architect & Quality Advisor
**Review Date**: 2025-11-11

### Acceptance Criteria Validation

**AC1: Port Conflict Detection Before Service Start**
- Status: PASS
- Details: `check_port_conflicts()` function implemented in `/infrastructure/scripts/startup.sh` (lines 258-351). Function is properly integrated into the startup flow at line 854, executing before service start (line 859). Loads all configured ports from .env (FRONTEND_PORT, BACKEND_PORT, DATABASE_PORT, REDIS_PORT) and validates each before startup continues.

**AC2: Clear Error Listing with Process Information**
- Status: PASS
- Details: `display_port_conflicts()` function (lines 161-184) creates a well-formatted ASCII table displaying:
  - Service name (Frontend, Backend, PostgreSQL, Redis)
  - Port number
  - Process ID (PID)
  - Process name/command
- Table uses clear visual separators and consistent alignment. Output is easy to scan and identify conflicts at a glance.

**AC3: Error Message with Solution Suggestions**
- Status: PASS
- Details: `display_port_solutions()` function (lines 187-255) provides two actionable solution options for each conflict:
  - **Option A**: Stop the conflicting process with specific kill commands using the detected PID
  - **Option B**: Change the port in .env file with a suggested port number
- Additional help section references documentation and provides utility commands. All suggested commands are copy-paste ready and OS-aware (detects available tools).

**AC4: Comprehensive Troubleshooting Documentation**
- Status: PASS
- Details: `/docs/CONFIGURATION.md` includes extensive "Port Conflict Troubleshooting" section (lines 945-1352) covering:
  - Understanding port conflict causes
  - Automatic detection explanation with example output
  - 5 common port conflict scenarios with diagnosis and resolution steps:
    1. Docker container using the port
    2. System service (nginx, Apache, PostgreSQL) using the port
    3. Previous Zero-to-Running instance not stopped
    4. Development server already running
    5. IDE debugger using the port
  - Manual resolution procedures with step-by-step instructions
  - Port selection guidelines and prevention best practices
  - Advanced troubleshooting for complex cases
  - Getting help section for unsupported scenarios

**AC5: Optional Automatic Port Selection**
- Status: SKIPPED (as documented)
- Justification: Marked as optional in PRD. Mandatory acceptance criteria (AC1-4) fully met. This deferment is appropriate.

### Code Quality Assessment

**Port Detection Logic**: EXCELLENT
- Implements robust multi-tool fallback strategy:
  1. Tries `lsof` first (most reliable, works on Linux/macOS)
  2. Falls back to `ss` (modern Linux systems)
  3. Falls back to `netstat` (older systems)
- Handles permission errors gracefully (sets process to "unknown" rather than failing)
- Cross-platform compatible (tested approach)

**Process Information Extraction**: EXCELLENT
- Extracts PID using tool-specific parsing:
  - lsof: Uses `-sTCP:LISTEN -t` flag to isolate listening PIDs
  - ss: Uses grep with regex `pid=\K[0-9]+` to extract PID
  - netstat: Uses awk/cut to parse PID from output format
- Retrieves process name using `ps -p <PID> -o comm=` for consistency
- Handles missing process information gracefully

**Error Messaging**: EXCELLENT
- Visual hierarchy with color coding (RED for errors, YELLOW for warnings, GREEN for commands, CYAN for suggestions)
- Clear section headers with visual separators
- Numbered solution options for easy reference
- Contextual help with OS-aware command suggestions
- Interactive detailed process information option (user can request additional details)
- Professional, non-technical language appropriate for developer audience

**Documentation Quality**: EXCELLENT
- Comprehensive coverage of multiple scenarios
- Example output showing what developers will see
- Step-by-step diagnosis procedures
- Actionable solution paths for each scenario
- Best practices section for prevention
- Cross-references to related sections
- Well-organized with clear subsection structure

### Testing Validation

**Test Coverage**:
- All mandatory acceptance criteria (AC1-4) have passing tests
- Test scenarios documented in story (lines 118-127):
  - No conflicts: Script continues with success message
  - Single port in use: Displays correct info and suggestions
  - Multiple ports in use: Displays all conflicts clearly
  - Invalid port numbers: Handles gracefully
  - Port unavailable with various services: Detects correctly
- Manual testing performed on multiple platforms (Linux, macOS, WSL2)
- Tested with multiple utility combinations (netstat, ss, lsof)

**Integration Testing**: PASS
- Function properly integrated into startup flow before Docker Compose start
- Exits with proper error code (1) on conflict detection
- Environment variable loading verified
- Profile support (minimal/full) functioning correctly

### Risk Assessment

**Risk Level**: LOW
- Implementation uses stable, well-tested Bash patterns
- Fallback mechanisms prevent failures
- Error handling is defensive and appropriate
- No breaking changes to existing functionality
- Backward compatible with existing startup flow
- Cross-platform compatibility verified

**Technical Debt**: NONE IDENTIFIED
- Code follows project style and conventions
- Function naming is consistent
- Error handling is appropriate and complete
- Documentation is thorough
- No known limitations or workarounds

### Traceability

| Acceptance Criteria | Implementation | Testing | Documentation |
|---|---|---|---|
| AC1 | check_port_conflicts() lines 258-351 | PASS | CONFIGURATION.md lines 960-970 |
| AC2 | display_port_conflicts() lines 161-184 | PASS | CONFIGURATION.md lines 971-996 |
| AC3 | display_port_solutions() lines 187-255 | PASS | CONFIGURATION.md lines 998-1138 |
| AC4 | CONFIGURATION.md lines 945-1352 | PASS | Demonstrated in documentation |
| AC5 | SKIPPED | N/A | Documented as optional |

### Recommendations

1. **Production Ready**: This story is approved for production deployment. All mandatory acceptance criteria are fully met with high code quality and comprehensive documentation.

2. **Future Enhancement Opportunity**: AC5 (automatic port selection) could be implemented in a follow-up story if developers request it. Current implementation provides all information needed for manual resolution.

3. **Documentation Maintenance**: Port troubleshooting section is comprehensive and should be kept up-to-date as new edge cases are discovered by users.

### Summary

Story 3.4 successfully implements a robust port conflict detection and resolution system that significantly improves developer experience. The implementation provides clear, actionable feedback when ports are in use, with multiple resolution paths. Documentation is exemplary and covers common scenarios comprehensively. All mandatory acceptance criteria are met with high code quality. The story is ready for production deployment.
