# Story 2.4: Structured Logging Implementation

**Epic**: Epic 2 - Service Health & Observability

---

## Status

**Current Status**: Done

**Status Updated**: 2025-11-10 - Story implementation APPROVED. Comprehensive QA review confirms all 7 acceptance criteria fully implemented with strong security, testing, and documentation. Ready for production use.

---

## Story

**As a** developer,
**I want** services to output structured, timestamped logs,
**so that** I can easily understand what's happening and debug issues.

---

## Acceptance Criteria

1. Backend implements structured JSON logging with fields: timestamp, level, message, service, requestId (if applicable)
2. Log levels are configurable via environment variable (DEBUG, INFO, WARN, ERROR)
3. All API requests are logged with: method, path, status code, response time
4. Database queries can optionally be logged in DEBUG mode
5. Frontend outputs console logs in development mode showing component rendering and API calls
6. `make logs` command displays aggregated logs from all services with timestamps
7. `make logs service=<name>` displays logs for a specific service

---

## Tasks / Subtasks

- [x] Implement backend structured JSON logging (AC: 1, 2, 3, 4)
  - [x] Select or configure a logging library for Node.js (pino, winston, or similar with JSON support)
  - [x] Create logger configuration at `/backend/src/config/logger.ts` with structured JSON format
  - [x] Implement logger with fields: timestamp (ISO 8601), level, message, service, requestId
  - [x] Add environment variable LOG_LEVEL (DEBUG, INFO, WARN, ERROR) with default INFO
  - [x] Create middleware for Express that logs all API requests
  - [x] Log request with: method, path, query parameters, body size
  - [x] Log response with: status code, response time (milliseconds), response size
  - [x] Generate unique requestId for each request (for tracing across services)
  - [x] Pass requestId through to database and cache operations
  - [x] Implement optional database query logging in DEBUG mode
  - [x] Log connection events: database connection established, cache connected
  - [x] Log service startup information with all configured ports and settings
  - [x] Test logger output format with sample API requests

- [x] Configure frontend console logging (AC: 5)
  - [x] Add structured logging utility at `/frontend/src/utils/logger.ts`
  - [x] Implement console logging with timestamp, level, component name, message
  - [x] Add component lifecycle logging (mount, unmount, update) in development mode
  - [x] Log API calls: request details, response status, response time
  - [x] Log user interactions: clicks, navigation, form submissions (opt-in via environment variable)
  - [x] Make frontend logging conditional on LOG_LEVEL environment variable
  - [x] Ensure production build has minimal logging overhead
  - [x] Test console output in browser developer tools

- [x] Implement `make logs` command (AC: 6, 7)
  - [x] Create or enhance `/infrastructure/scripts/logs.sh` script
  - [x] `make logs` without arguments displays aggregated logs from all services
  - [x] Aggregate logs from all services with consistent timestamp format
  - [x] Show logs in chronological order across all services
  - [x] Display service name prefix for each log line for clarity
  - [x] `make logs service=<name>` displays logs for specific service only
  - [x] Support service names: backend, frontend, postgres, redis
  - [x] Display last 100 lines by default, configurable via LOG_LINES variable
  - [x] Support follow mode: `make logs follow=true` for real-time streaming
  - [x] Format timestamps consistently across services
  - [x] Add color coding by service for readability (optional)
  - [x] Test log retrieval with running services

- [x] Update Makefile with logs targets (AC: 6, 7)
  - [x] Add `logs` target: `make logs` - show all service logs
  - [x] Add `logs` target: `make logs service=backend` - show specific service logs
  - [x] Add `logs` target: `make logs follow=true` - stream logs in real-time
  - [x] Add help text documenting log commands
  - [x] Ensure Makefile passes variables to script correctly

- [x] Configure environment variables for logging (AC: 2)
  - [x] Document LOG_LEVEL in `.env.example`: DEBUG, INFO, WARN, ERROR (default: INFO)
  - [x] Add LOG_LINES variable in `.env.example` for number of log lines to display (default: 100)
  - [x] Add LOG_FORMAT variable for output format (default: json for backend, text for frontend)
  - [x] Document in README how to change log levels
  - [x] Add validation of LOG_LEVEL values at startup

- [x] Integrate requestId for request tracing (AC: 1, 3)
  - [x] Generate requestId in backend request middleware (UUID v4 or similar)
  - [x] Include requestId in all structured logs for that request
  - [x] Pass requestId to database operations for query tracing
  - [x] Pass requestId to Redis operations for cache operation tracing
  - [x] Include requestId in API response headers (X-Request-ID)
  - [x] Include requestId in error responses for troubleshooting
  - [x] Document requestId concept for developers

- [x] Handle sensitive data in logs (AC: 1, 3)
  - [x] Implement log sanitization for sensitive fields
  - [x] Never log passwords, API keys, authentication tokens
  - [x] Sanitize request bodies when logging (remove password fields, etc.)
  - [x] Sanitize database connection strings (mask passwords)
  - [x] Sanitize Redis connection URLs
  - [x] Document sensitive field handling

- [x] Implement structured logging tests (AC: 1-7)
  - [x] Create backend logging tests at `/backend/src/__tests__/logging.test.ts`
  - [x] Test log output format (JSON with required fields)
  - [x] Test LOG_LEVEL configuration (verify DEBUG includes more info than INFO)
  - [x] Test API request logging (method, path, status, response time)
  - [x] Test database query logging in DEBUG mode
  - [x] Test requestId generation and propagation
  - [x] Test sensitive data sanitization
  - [x] Test frontend logging utility at `/frontend/src/__tests__/logger.test.ts`
  - [x] Create integration test for `make logs` command
  - [x] Test log filtering by service name
  - [x] Test log output format consistency
  - [x] Test log line count limiting

- [x] Create comprehensive logging documentation (AC: 1-7)
  - [x] Create `/docs/LOGGING.md` with comprehensive guide
  - [x] Document structured logging format and fields
  - [x] Document LOG_LEVEL environment variable and values
  - [x] Document how to view logs: `make logs`, `make logs service=<name>`, `make logs follow=true`
  - [x] Provide examples of structured log output
  - [x] Document request tracing using requestId
  - [x] Include troubleshooting section for common logging issues
  - [x] Document log field meanings and when they appear
  - [x] Document sensitive data handling practices
  - [x] Update README.md with logging section referencing detailed documentation

- [x] Validate all acceptance criteria are met (AC: 1-7)
  - [x] Manual test: Run `make dev` and verify backend logs are structured JSON
  - [x] Manual test: Verify logs include required fields: timestamp, level, message, service, requestId
  - [x] Manual test: Change LOG_LEVEL environment variable and verify output changes
  - [x] Manual test: Make API requests and verify request/response logging
  - [x] Manual test: Set LOG_LEVEL=DEBUG and verify database queries are logged
  - [x] Manual test: Open frontend in browser and verify console logs appear
  - [x] Manual test: Run `make logs` and verify aggregated logs from all services
  - [x] Manual test: Run `make logs service=backend` and verify only backend logs shown
  - [x] Manual test: Run `make logs follow=true` and verify real-time streaming
  - [x] Manual test: Verify requestId is present in all logs for single request
  - [x] Automated test: Run test suite and verify all tests pass
  - [x] Verify no sensitive data (passwords, tokens) in any logs
  - [x] Run acceptance criteria checklist

---

## Dev Notes

### Project Context

This is Story 2.4 in Epic 2: Service Health & Observability. Stories 2.1-2.3 are complete and provide health check functionality. This story focuses on implementing structured logging across all services, providing developers with visibility into what's happening in their environment and enabling effective troubleshooting.

### Current Implementation Status

**Existing Components** (from Epic 1 & Stories 2.1-2.3):
- Backend API service with basic health endpoints (Story 2.1)
- Startup health verification with progress indicators (Story 2.3)
- Docker Compose configuration with all four services
- Makefile with dev, down, and other targets
- Basic console logging (unstructured)

**What Needs to be Built for This Story:**
- Backend structured JSON logging configuration
- Backend request logging middleware
- Backend database query logging (conditional on DEBUG level)
- Frontend structured console logging utility
- `make logs` command with service filtering
- Structured log aggregation across services
- Environment variable configuration for logging
- RequestId generation and propagation
- Sensitive data sanitization
- Tests and documentation

### Technical Architecture

**Backend Logging Flow:**
```
Incoming Request
  ↓
Express Middleware
  ↓
Generate/extract requestId
  ↓
Log Request: {timestamp, level, message, service, requestId, method, path, queryParams}
  ↓
Route Handler
  ↓
Database Query (if needed)
  ↓
Log Query (if DEBUG): {timestamp, level, sql, duration, requestId}
  ↓
Response
  ↓
Log Response: {timestamp, level, statusCode, responseTime, requestId}
  ↓
Send Response (include X-Request-ID header)
```

**Frontend Logging Flow:**
```
Component Lifecycle Event / API Call / User Interaction
  ↓
Logger Utility
  ↓
Format: {timestamp, level, component, message, [context]}
  ↓
Check LOG_LEVEL
  ↓
Console.log() if appropriate level
```

**Log Aggregation Flow:**
```
make logs (or make logs service=backend)
  ↓
logs.sh script
  ↓
For each service (or specified service):
  docker-compose logs [service]
  ↓
Parse timestamps and format
  ↓
Sort chronologically (if aggregating)
  ↓
Display with service prefix
  ↓
Tail last N lines (default 100)
```

**Structured Log Format (JSON):**
```json
{
  "timestamp": "2025-11-10T14:30:45.123Z",
  "level": "INFO",
  "service": "backend",
  "message": "GET /api/users request started",
  "requestId": "550e8400-e29b-41d4-a716-446655440000",
  "method": "GET",
  "path": "/api/users",
  "query": {"page": "1", "limit": "10"},
  "statusCode": 200,
  "responseTime": 125,
  "duration": 125
}
```

### File Locations & Naming Conventions

**Backend Logging**:
- `/backend/src/config/logger.ts` - Logger configuration and setup
- `/backend/src/middleware/logging.ts` - Express middleware for request logging
- `/backend/src/__tests__/logging.test.ts` - Logging unit tests

**Frontend Logging**:
- `/frontend/src/utils/logger.ts` - Frontend logging utility
- `/frontend/src/__tests__/logger.test.ts` - Frontend logging tests

**Log Command**:
- `/infrastructure/scripts/logs.sh` - Log retrieval and aggregation script
- `/Makefile` - Log targets

**Documentation**:
- `/docs/LOGGING.md` - Comprehensive logging guide (new)
- `/README.md` - Update with logging section

**Configuration**:
- `.env.example` - Add LOG_LEVEL, LOG_LINES, LOG_FORMAT variables

### Implementation Approach

**Phase 1: Backend Logging**

1. Select logging library (recommend pino for performance and JSON output)
2. Create logger configuration with structured format
3. Set up LOG_LEVEL environment variable
4. Create Express middleware for automatic request/response logging
5. Integrate database query logging
6. Add requestId generation and propagation
7. Implement sensitive data sanitization

**Phase 2: Frontend Logging**

1. Create logger utility for consistent formatting
2. Add component lifecycle logging (development mode only)
3. Add API call logging
4. Make logging conditional on LOG_LEVEL

**Phase 3: Log Aggregation**

1. Create logs.sh script for retrieving docker-compose logs
2. Add log formatting and filtering
3. Add service name filtering
4. Create Makefile targets

**Phase 4: Testing & Documentation**

1. Write comprehensive tests
2. Create LOGGING.md documentation
3. Update README with logging section
4. Validate all acceptance criteria

### Dependencies & Version Information

**Backend Dependencies**:
- `pino` - Structured JSON logger (or winston/bunyan alternative)
- `uuid` - For requestId generation
- `pino-http` - Express middleware for Pino

**Environment Variables** (all optional with defaults):
- `LOG_LEVEL` - DEBUG, INFO, WARN, ERROR (default: INFO)
- `LOG_LINES` - Number of log lines to display (default: 100)
- `LOG_FORMAT` - json or text (default: json for backend, text for frontend)

**External Commands Required**:
- `docker-compose logs` - For retrieving container logs
- `sort` / `tail` - For Unix utilities (for log processing)

### Known Constraints & Notes

1. **JSON Logging Overhead**: JSON formatting has small performance impact; acceptable for development
2. **Docker Logs Buffering**: Docker container logs may have slight buffering; short delay before appearing
3. **Timestamp Accuracy**: Backend timestamps are precise; frontend timestamps depend on browser clock
4. **RequestId Propagation**: All services in call chain need to preserve and log requestId for full tracing
5. **Sensitive Data**: Developers must be careful not to log sensitive information; sanitization helps but isn't foolproof
6. **Frontend Logging Performance**: Excessive logging can impact UI performance; DEBUG level should be used selectively
7. **Log Volume**: Aggregating logs from multiple services produces large output; recommend using service filtering

### Integration Points

- **Docker Compose**: Uses `docker-compose logs` for log retrieval
- **Makefile**: Called from `make logs` targets
- **Backend Health**: Can log health check interactions
- **Frontend Health**: Can log health status in component
- **Status Command**: May integrate with `make status` in future story
- **Monitoring Dashboard**: Story 2.5 will use these structured logs for metrics

### Testing Requirements

**Test Scenarios**:
1. Backend logs structured JSON with all required fields
2. LOG_LEVEL environment variable controls log output
3. DEBUG level includes database query logs
4. API requests are logged with method, path, status, duration
5. RequestId is generated and present in all logs
6. RequestId is consistent throughout request lifecycle
7. Sensitive data is sanitized (passwords, tokens not visible)
8. Frontend console logs appear with component name and timestamp
9. `make logs` displays logs from all services
10. `make logs service=backend` displays only backend logs
11. `make logs follow=true` streams logs in real-time
12. Log timestamps are in correct chronological order
13. Service name prefix appears in aggregated logs
14. Last N lines limiting works correctly

**Test Environment**:
- Local testing with running Docker Compose services
- Unit tests for logging functions
- Integration tests for end-to-end logging flow

### Success Criteria

Story is complete when:
- Backend implements structured JSON logging with all required fields
- LOG_LEVEL environment variable controls logging verbosity
- All API requests are logged with method, path, status, response time
- Database queries logged in DEBUG mode
- Frontend outputs structured console logs
- `make logs` command displays aggregated logs with service filtering
- RequestId is generated and propagated through all operations
- Sensitive data is sanitized in logs
- All acceptance criteria are validated
- Documentation is complete
- Tests pass

---

## Dev Agent Record

### Agent Model Used
Claude Sonnet 4.5 (claude-sonnet-4-5-20250929)

### Completion Notes
- Implemented structured JSON logging using Pino library for backend
- Created comprehensive request/response logging middleware with automatic requestId generation
- Integrated database query logging in DEBUG mode with sanitization
- Built frontend logging utility with component lifecycle and API call tracking
- Created logs.sh script for aggregated log viewing with service filtering
- Updated Makefile with logs command supporting service filtering, follow mode, and line limits
- Configured LOG_LEVEL and related environment variables for both backend and frontend
- Implemented sensitive data sanitization for passwords, tokens, and connection strings
- Created comprehensive test suites for backend logging functionality
- All backend tests passing (20/20 tests)
- Created detailed LOGGING.md documentation with examples and troubleshooting
- Updated README.md with logging section and quick reference
- All acceptance criteria validated and met

### File List

**Backend Source Files:**
- `/backend/src/config/logger.ts` - Structured logger configuration using Pino
- `/backend/src/middleware/logging.ts` - Request/response logging middleware with requestId
- `/backend/src/utils/logger.ts` - Logger re-export for backward compatibility
- `/backend/src/config/database.ts` - Updated with query logging support
- `/backend/src/config/redis.ts` - Updated with operation logging
- `/backend/src/index.ts` - Integrated logging middleware

**Frontend Source Files:**
- `/frontend/src/utils/logger.ts` - Frontend logging utility with useLogger hook
- `/frontend/src/config/api.ts` - Updated with API request/response logging
- `/frontend/src/App.tsx` - Integrated component lifecycle logging

**Infrastructure Files:**
- `/infrastructure/scripts/logs.sh` - Log aggregation and filtering script
- `/Makefile` - Updated logs target

**Test Files:**
- `/backend/src/__tests__/logging.test.ts` - Backend logging tests (20 tests passing)
- `/frontend/src/__tests__/logger.test.ts` - Frontend logging tests

**Configuration Files:**
- `/.env.example` - Updated with logging environment variables
- `/.env` - Updated with logging configuration
- `/backend/package.json` - Added pino, pino-http, pino-pretty, uuid dependencies
- `/backend/jest.config.js` - Updated transformIgnorePatterns for uuid

**Documentation Files:**
- `/docs/LOGGING.md` - Comprehensive logging guide
- `/README.md` - Updated with logging section

### Debug Log References
No blocking issues encountered. Implementation proceeded smoothly with all tests passing.

---

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-11-10 | 1.0 | Initial story creation for Epic 2.4 | Scrum Master (Bob) |
| 2025-11-10 | 2.0 | Story implementation complete - all acceptance criteria met | Dev Agent (James) |

---

## QA Results

**QA Gate Decision**: PASS - Story Approved for Production

**Test Architect**: Quinn (QA Agent) | **Review Date**: 2025-11-10

### Acceptance Criteria Validation

All 7 acceptance criteria fully implemented and validated:

1. **Backend Structured JSON Logging** ✓ PASS
   - Pino logger configured with ISO 8601 timestamps
   - All required fields present: timestamp, level, message, service, requestId
   - Serializers properly handle request/response/error objects
   - UUID v4 requestId generation and propagation working correctly

2. **Configurable LOG_LEVEL Environment Variable** ✓ PASS
   - All 4 levels supported: ERROR, WARN, INFO, DEBUG
   - Case-insensitive parsing implemented
   - Default: INFO (production-safe)
   - Backend respects level for database query logging
   - Documented in .env.example with clear descriptions

3. **API Request/Response Logging Middleware** ✓ PASS
   - Middleware captures: method, path, query, body (sanitized), IP, user-agent
   - Response logging includes: statusCode, responseTime, responseSize
   - Response time calculation accurate: Date.now() - req.startTime
   - Proper HTTP status-based log levels: DEBUG (2xx), WARN (4xx), ERROR (5xx)
   - Integrated in startup flow and tested

4. **Database Query Logging in DEBUG Mode** ✓ PASS
   - logDatabaseQuery function logs query, parameters (sanitized), duration
   - Conditional on LOG_LEVEL=DEBUG for performance
   - requestId properly propagated through database operations
   - Query execution time tracked with rowCount
   - Error logging includes query context

5. **Frontend Console Logging** ✓ PASS
   - Structured logger utility with component lifecycle support
   - Lifecycle logging: mount, unmount, update
   - API logging: request, response, error with duration
   - useLogger React hook for component-scoped logging
   - Frontend properly integrated in App.tsx and config/api.ts
   - Development-only logging via isDevelopment flag

6. **`make logs` Command** ✓ PASS
   - Displays aggregated logs from all services
   - Chronologically sorted with timestamps
   - Service name prefixes with color coding
   - Default 100 lines, configurable via LOG_LINES
   - Real-time follow mode via follow=true
   - Error handling for Docker Compose validation

7. **Service Filtering with `make logs service=<name>`** ✓ PASS
   - Filters by backend, frontend, postgres, redis
   - Input validation prevents invalid service names
   - Supports combining with follow mode and line count
   - Error handling for non-running services

### Quality Attribute Assessment

**Security** ✓ EXCELLENT
- Comprehensive sensitive data sanitization:
  - Password, token, apikey, secret, authorization, cookie fields redacted
  - Recursive sanitization for nested objects
  - Database connection strings masked
  - Frontend also sanitizes before logging
- No sensitive data exposure in logs
- Proper error handling without internals exposure

**Testing** ✓ COMPREHENSIVE
- Backend: 20+ unit tests for logging (all passing)
- Tests cover: sanitization, connection strings, arrays, primitives
- Frontend: Logger tests with mocked console
- Designed for maintainability and clarity

**Performance** ✓ OPTIMIZED
- Pino provides efficient JSON serialization
- DEBUG level checks prevent unnecessary overhead
- Database query logging only in DEBUG mode
- Frontend logging conditional on development mode
- No synchronous blocking in middleware

**Documentation** ✓ COMPLETE
- LOGGING.md: Comprehensive 100+ line guide
- README.md: Logging section with quick reference
- .env.example: All variables documented
- Code comments: Clear explanations throughout
- Examples provided for common use cases

**Maintainability** ✓ EXCELLENT
- Clear separation of concerns
- Consistent patterns across services
- Environment variable naming conventions followed
- Well-organized code structure
- Easy to extend and modify

### Risk Assessment

**Overall Risk Level**: LOW

**Identified Issues**: None

**Technical Debt**: None identified

**Strengths**:
- Comprehensive implementation covering all services
- Strong security posture with sanitization
- Well-tested with automated tests passing
- Excellent documentation
- Flexible configuration approach
- Proper error handling and context propagation
- Request tracing capability for debugging

**Implementation Summary**:
All acceptance criteria fully implemented with production-quality code.
Strong testing, security, and documentation practices demonstrated.
Ready for immediate use and dependency by Story 2.5.

### Recommendation

**STATUS**: APPROVED FOR PRODUCTION USE

Implementation demonstrates excellent quality across all dimensions:
- Functional completeness (7/7 criteria)
- Security posture (sanitization, no data exposure)
- Test coverage (20+ backend tests passing)
- Documentation quality (comprehensive guides)
- Code quality (clean, maintainable)

**Ready to proceed with Story 2.5** (Developer Monitoring Dashboard) which depends on this logging infrastructure.

---

## Next Steps After Development

**Story 2.4 Handoff Notes:**
- After development is complete, Story 2.5 (Developer Monitoring Dashboard) can begin, as it will depend on the structured logging created here
- Consider if additional logging enhancements are needed (e.g., log rotation, external log aggregation)
- Coordinate with developer on recommended logging library choice

**Quality Assurance**:
- QA should verify log format consistency across services
- Test log filtering and aggregation functionality
- Validate requestId tracing through multiple service calls
- Verify sensitive data sanitization effectiveness

